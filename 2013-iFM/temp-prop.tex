\subsection{Temporal Properties}
\label{sec:temporal-properties}
The temporal logic of \unity, on which ours is based, partitions temporal properties in two groups: progress properties and safety properties.
\todo{0.5 pages}

\subsubsection{Progress Properties}
\label{sec:progress-properties}
The main tool for expressing progress properties is the
\emph{leads-to} operator ($\mapsto$). For $p$ and $q$ two state
predicates, $p \mapsto q$ holds exactly for the computations in which
every state satisfying $p$ is eventually followed by a state (possibly
the same), satisfying $q$.
%
\begin{equation}
	\ew{ (p \mapsto q) \2\equiv \G (\bullet p \1\implies \F ; \bullet q) }
\end{equation}
%
The basic properties of $\mapsto$ make it reminiscent of the Hoare triple with the basic case, based on $\textbf{ensures}$ being analogous to the assignment rule, the disjunction rule to the rule for non-deterministic conditional statement, the transitivity rule to the rule for sequential composition and the induction rule to the rule for iteration.
\begin{itemize}
\item Transitivity
	\begin{equation}
		\ew{ (p \mapsto q)  \1\land (q \mapsto r) \2\implies  (p \mapsto r) }
			\label{sem:prog:lt:transitivity}
	\end{equation}
\item Disjunction \footnote{
%
In \cite{DBLP:books/daglib/0067338}, \cite{DBLP:journals/csur/Misra96}, the disjunction rule is presented as an implication (or more exactly, an inference rule) with $\qexists{i}{}{p.i} \mapsto q$ as the consequent.  However, in \cite{thesis/hudon2011}, we proved using a general formulation in computation calculus that the two parts of the rule are actually equivalent.  We see no reasons to refrain from using the equivalence. }
 %
	\begin{equation}
			\label{sem:prog:lt:disjunction} 
		\ew{ \qforall{i}{}{p.i \1\mapsto q }  \3{  \equiv }  \qexists{i}{}{p.i } \1\mapsto q  }
	\end{equation}
\item Induction
	\begin{equation}
%	\begin{array}{llll}
	\ew{  (p \1\land M = m  \2\mapsto (p \1\land M<m) \1\lor q) \3\implies (p \mapsto q)  }
%	\end{array} 
	\end{equation}
\end{itemize}


\subsubsection{Safety Properties}
\label{sec:safety-properties}
\todo{talk about $\G \_$}
\todo{$\s$ is undefined}
The main tool for expressing safety properties is the \emph{unless} operator ($\un$).  For $p$ and $q$ two state predicates, $p \un q$ holds exactly for the computations in which, once $p$ holds, it remains true for at least as long as $q$ is false.
%
\begin{equation}
	\ew{ (p \un q) \3\equiv \G (\bullet p \1\implies (\G \bullet p) ; \s ; \bullet q) }
\end{equation}
%
In the UNITY logic \cite{DBLP:books/daglib/0067338}, the unless operator is defined in terms of program execution but we have decided to separate the notions of program execution and temporal properties. 

\todo{list unless theorems}

\todo{ maybe we remove the proof of PSP }
\subsubsection{A Theorem: PSP}
As an example of what can be done with our computation calculus formulations, we offer the proof of the PSP theorem from \cite{DBLP:books/daglib/0067338} It is meant to show how straightforward a computation calculus proof is and how it relieves us from resorting to (meta-)proofs by induction over the structure of the proofs of the premise.
%
\begin{equation}
	\ew{ (\1{ p \land r \1\mapsto (q \land r) \lor b })  \3\follows  (p \mapsto q) \1\land (r \un b)  }
		\label{sem:prog:thm:psp}
\end{equation}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "progress"
%%% End: 
